{-
Ported from LibOrbis by Maxton
https://github.com/maxton/LibOrbisPkg
-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE LambdaCase            #-}
{-# LANGUAGE NoFieldSelectors      #-}
{-# LANGUAGE OverloadedRecordDot   #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE RecordWildCards       #-}
{-# LANGUAGE StrictData            #-}
module Onyx.PlayStation.PKG.PS4 where

import           Control.Monad
import           Control.Monad.Codec
import           Crypto.Cipher.AES        (AES128)
import           Crypto.Cipher.Types      (cbcDecrypt, cipherInit, makeIV)
import           Crypto.Error
import           Crypto.Hash
import           Crypto.PubKey.RSA.PKCS15 (decrypt)
import           Crypto.PubKey.RSA.Types  (PrivateKey (..), PublicKey (..))
import           Data.Binary.Get
import           Data.Binary.Put          (putWord32be, runPut)
import           Data.Bits                ((.&.))
import           Data.ByteArray           (convert)
import qualified Data.ByteString          as B
import qualified Data.ByteString.Lazy     as BL
import           Data.Foldable            (toList)
import           Data.Int
import           Data.Word
import           Onyx.Rocksmith.Sng2014   (nullTerm)
import           Onyx.Util.Binary         (runGetM)
import           Onyx.Xbox.STFS           (bytesToInteger)
import           System.IO

data Header = Header
  { magic              :: B.ByteString
  , flags              :: PKGFlags
  , unk_0x08           :: Word32
  , unk_0x0C           :: Word32 -- 0xF
  , entry_count        :: Word32
  , sc_entry_count     :: Word16
  , entry_count_2      :: Word16
  , entry_table_offset :: Word32
  , main_ent_data_size :: Word32
  , body_offset        :: Word64
  , body_size          :: Word64
  -- 0x10 bytes gap, zero?
  , content_id         :: B.ByteString -- 0x30 bytes null terminated
  , drm_type           :: DrmType
  , content_type       :: ContentType
  , content_flags      :: ContentFlags
  , promote_size       :: Word32
  , version_date       :: Word32
  , version_hash       :: Word32
  , unk_0x88           :: Word32 -- for delta patches only?
  , unk_0x8C           :: Word32 -- for delta patches only?
  , unk_0x90           :: Word32 -- for delta patches only?
  , unk_0x94           :: Word32 -- for delta patches only?
  , iro_tag            :: IROTag
  , ekc_version        :: Word32 -- drm type version
  -- 0x60 bytes gap, zero?
  , sc_entries1_hash   :: B.ByteString
  , sc_entries2_hash   :: B.ByteString
  , digest_table_hash  :: B.ByteString
  , body_digest        :: B.ByteString
  } deriving (Show)

type PKGFlags = Word32
type DrmType = Int32
type ContentType = Int32
type ContentFlags = Word32
type IROTag = Int32

readHeader :: Get Header
readHeader = do
  magic              <- getByteString 4
  when (magic /= "\x7F\x43\x4E\x54") $ fail $ "Unrecognized PS4 .pkg magic string: " <> show magic
  flags              <- getWord32be
  unk_0x08           <- getWord32be
  unk_0x0C           <- getWord32be
  entry_count        <- getWord32be
  sc_entry_count     <- getWord16be
  entry_count_2      <- getWord16be
  entry_table_offset <- getWord32be
  main_ent_data_size <- getWord32be
  body_offset        <- getWord64be
  body_size          <- getWord64be
  skip 0x10
  content_id         <- codecIn $ nullTerm 0x30
  drm_type           <- getInt32be
  content_type       <- getInt32be
  content_flags      <- getWord32be
  promote_size       <- getWord32be
  version_date       <- getWord32be
  version_hash       <- getWord32be
  unk_0x88           <- getWord32be
  unk_0x8C           <- getWord32be
  unk_0x90           <- getWord32be
  unk_0x94           <- getWord32be
  iro_tag            <- getInt32be
  ekc_version        <- getWord32be
  skip 0x60
  sc_entries1_hash   <- getByteString 0x20
  sc_entries2_hash   <- getByteString 0x20
  digest_table_hash  <- getByteString 0x20
  body_digest        <- getByteString 0x20
  return Header{..}

-- Maxton had these in Header, but wrote:
-- "TODO i think these fields are actually members of element of container array"
data Header0x400 = Header0x400
  { unk_0x400            :: Word32
  , pfs_image_count      :: Word32
  , pfs_flags            :: Word64
  , pfs_image_offset     :: Word64
  , pfs_image_size       :: Word64
  , mount_image_offset   :: Word64
  , mount_image_size     :: Word64
  , package_size         :: Word64
  , pfs_signed_size      :: Word32
  , pfs_cache_size       :: Word32
  , pfs_image_digest     :: B.ByteString
  , pfs_signed_digest    :: B.ByteString
  , pfs_split_size_nth_0 :: Word64
  , pfs_split_size_nth_1 :: Word64
  } deriving (Show)

readHeader0x400 :: Get Header0x400
readHeader0x400 = do
  unk_0x400            <- getWord32be
  pfs_image_count      <- getWord32be
  pfs_flags            <- getWord64be
  pfs_image_offset     <- getWord64be
  pfs_image_size       <- getWord64be
  mount_image_offset   <- getWord64be
  mount_image_size     <- getWord64be
  package_size         <- getWord64be
  pfs_signed_size      <- getWord32be
  pfs_cache_size       <- getWord32be
  pfs_image_digest     <- getByteString 0x20
  pfs_signed_digest    <- getByteString 0x20
  pfs_split_size_nth_0 <- getWord64be
  pfs_split_size_nth_1 <- getWord64be
  return Header0x400{..}

data PKG = PKG
  { header          :: Header
  , header0x400     :: Header0x400
  , headerDigest    :: B.ByteString
  , headerSignature :: B.ByteString
  , metas           :: [MetaEntry (Maybe EntryContents)]
  } deriving (Show)

readPKG :: Handle -> IO PKG
readPKG h = do
  hSeek h AbsoluteSeek 0
  headerBytes     <- BL.hGet h 0x5A0
  header          <- runGetM readHeader headerBytes
  header0x400     <- runGetM readHeader0x400 $ BL.drop 0x400 headerBytes
  hSeek h AbsoluteSeek 0xFE0
  headerDigest    <- B.hGet h 32
  headerSignature <- B.hGet h 256
  hSeek h AbsoluteSeek $ fromIntegral header.entry_table_offset
  metasBytes      <- BL.hGet h $ 0x20 * fromIntegral header.entry_count
  metasEmpty      <- flip runGetM metasBytes $ replicateM (fromIntegral header.entry_count) $ do
    id_ <- getWord32be
    nameTableOffset <- getWord32be
    flags1 <- getWord32be
    flags2 <- getWord32be
    dataOffset <- getWord32be
    dataSize <- getWord32be
    skip 8
    return MetaEntry { entryContents = Nothing, .. }
  metas <- forM metasEmpty $ \meta -> let
    readStrict f = do
      hSeek h AbsoluteSeek $ fromIntegral meta.dataOffset
      bs <- B.hGet h $ fromIntegral meta.dataSize
      return meta { entryContents = Just $ f bs }
    in case meta.id_ of
      0x10 -> do -- ENTRY_KEYS
        hSeek h AbsoluteSeek $ fromIntegral meta.dataOffset
        seedDigest <- B.hGet h 32
        digests <- replicateM 7 $ B.hGet h 32
        keyBytes <- replicateM 7 $ B.hGet h 256
        let keys = zipWith PkgEntryKey digests keyBytes
        return meta { entryContents = Just $ KeysEntry Keys{..} }
      0x20 -> readStrict ImageKeyEntry -- IMAGE_KEY
      _ -> return meta
  return PKG{..}

data MetaEntry a = MetaEntry
  { id_             :: EntryId
  , nameTableOffset :: Word32
  , flags1          :: Word32
  , flags2          :: Word32
  , dataOffset      :: Word32
  , dataSize        :: Word32
  , entryContents   :: a
  } deriving (Show)

type EntryId = Word32

-- TODO rest of parsed entry types
data EntryContents
  = GenericEntry BL.ByteString
  | KeysEntry Keys
  | ImageKeyEntry B.ByteString
  deriving (Show)

-- instance Show EntryContents where
--   show = \case
--     GenericEntry{} -> "GenericEntry{...}"

data Keys = Keys
  { seedDigest :: B.ByteString
  , keys       :: [PkgEntryKey]
  } deriving (Show)

data PkgEntryKey = PkgEntryKey
  { digest :: B.ByteString
  , key    :: B.ByteString
  } deriving (Show)

imageKeyGetBytes :: MetaEntry a -> B.ByteString
imageKeyGetBytes me = BL.toStrict $ runPut $ do
  putWord32be me.id_
  putWord32be me.nameTableOffset
  putWord32be me.flags1
  putWord32be me.flags2
  putWord32be me.dataOffset
  putWord32be me.dataSize
  putWord32be 0
  putWord32be 0

--------------------------------------------------------------------------------

data PfsHeader = PfsHeader
  { version          :: Int64
  , magic            :: Int64
  , id_              :: Int64
  , fmode            :: Word8
  , clean            :: Word8
  , readOnly         :: Word8
  , rsv              :: Word8
  , mode             :: PfsMode
  , unk1             :: Word16
  , blockSize        :: Word32
  , nBackup          :: Word32
  , nBlock           :: Int64
  , dinodeCount      :: Int64
  , ndblock          :: Int64
  , dinodeBlockCount :: Int64
  , inodeBlockSig    :: DinodeS64
  , seed             :: B.ByteString
  } deriving (Show)

type PfsMode = Word16

data Inode a = Inode
  { mode           :: InodeMode
  , nlink          :: Word16
  , flags          :: InodeFlags
  , size           :: Int64
  , sizeCompressed :: Int64
  , time1_sec      :: Int64
  , time2_sec      :: Int64
  , time3_sec      :: Int64
  , time4_sec      :: Int64
  , time1_nsec     :: Word32
  , time2_nsec     :: Word32
  , time3_nsec     :: Word32
  , time4_nsec     :: Word32
  , uid            :: Word32
  , gid            :: Word32
  , unk1           :: Word64
  , unk2           :: Word64
  , blocks         :: a
  , db             :: [BlockSig a] -- count 12
  , ib             :: [BlockSig a] -- count 5
  } deriving (Show)

type InodeMode = Word16
type InodeFlags = Word32

type DinodeS64 = Inode Int64
type DinodeS32 = Inode Int32
type DinodeD32 = Inode Word32

readInode :: Get a -> Get (Inode a)
readInode getBlockType = do
  mode           <- getWord16le
  nlink          <- getWord16le
  flags          <- getWord32le
  size           <- getInt64le
  sizeCompressed <- getInt64le
  time1_sec      <- getInt64le
  time2_sec      <- getInt64le
  time3_sec      <- getInt64le
  time4_sec      <- getInt64le
  time1_nsec     <- getWord32le
  time2_nsec     <- getWord32le
  time3_nsec     <- getWord32le
  time4_nsec     <- getWord32le
  uid            <- getWord32le
  gid            <- getWord32le
  unk1           <- getWord64le
  unk2           <- getWord64le
  blocks         <- getBlockType
  db             <- replicateM 12 $ readBlockSig getBlockType
  ib             <- replicateM 5 $ readBlockSig getBlockType
  return Inode{..}

data BlockSig a = BlockSig
  { sig   :: B.ByteString
  , block :: a
  } deriving (Show)

readBlockSig :: Get a -> Get (BlockSig a)
readBlockSig getBlockType = do
  sig <- getByteString 32
  block <- getBlockType
  return BlockSig{..}

readPfsHeader :: Get PfsHeader
readPfsHeader = do
  start            <- bytesRead
  version          <- getInt64le
  magic            <- getInt64le
  id_              <- getInt64le
  fmode            <- getWord8
  clean            <- getWord8
  readOnly         <- getWord8
  rsv              <- getWord8
  mode             <- getWord16le
  unk1             <- getWord16le
  blockSize        <- getWord32le
  nBackup          <- getWord32le
  nBlock           <- getInt64le
  dinodeCount      <- getInt64le
  ndblock          <- getInt64le
  dinodeBlockCount <- getInt64le
  skip 8 -- skip a 64-bit zero
  inodeBlockSig    <- readInode getInt64le
  when (version /= 1 || magic /= 20130315) $ fail "Invalid PFS superblock version or magic"
  current          <- bytesRead
  skip $ fromIntegral $ (start + 0x370) - current
  seed             <- getByteString 16
  return PfsHeader{..}

data Pfs = Pfs
  { header  :: PfsHeader
  -- TODO
  , dinodes :: Either [DinodeS32] [DinodeD32]
  } deriving (Show)

data PfsDecrypt
  = EKPFS B.ByteString
  | TweakData B.ByteString B.ByteString

readPfs :: Handle -> PKG -> IO Pfs
readPfs h pkg = do
  hSeek h AbsoluteSeek $ fromIntegral pkg.header0x400.pfs_image_offset
  header <- BL.hGet h 0x400 >>= runGetM readPfsHeader

  let flagSigned    = (header.mode .&. 1) == 1
      flagEncrypted = (header.mode .&. 4) == 4

  -- TODO
  let dinodes = Left []
  return Pfs{..}

-- Decrypts the EKPFS for a fake PKG. Will not work on non-fake PKGs.
getEkpfs :: (MonadFail m) => PKG -> m B.ByteString
getEkpfs pkg = do

  keys <- case [ keys | entry <- pkg.metas, KeysEntry keys <- toList entry.entryContents ] of
    []    -> fail "Couldn't find ENTRY_KEYS"
    k : _ -> return k
  (ikEntryBytes, imageKeyEncrypted) <- case [ (imageKeyGetBytes entry, key) | entry <- pkg.metas, ImageKeyEntry key <- toList entry.entryContents ] of
    []    -> fail "Couldn't find IMAGE_KEY"
    x : _ -> return x

  -- var dk3 = Crypto.RSA2048Decrypt(EntryKeys.Keys[3].key, RSAKeyset.PkgDerivedKey3Keyset);
  key3 <- case drop 3 keys.keys of
    []    -> fail "Couldn't get keys[3]"
    k : _ -> return k.key
  dk3 <- case decrypt Nothing pkgDerivedKey3Keyset key3 of
    Left  e -> fail $ "Couldn't decrypt keys[3]: " <> show e
    Right k -> return k

  -- var iv_key = Crypto.Sha256(ImageKey.meta.GetBytes().Concat(dk3).ToArray());
  let iv_key = convert (hash $ ikEntryBytes <> dk3 :: Digest SHA256)

  -- var imageKeyDecrypted = ImageKey.FileData.Clone() as byte[];
  -- Crypto.AesCbcCfb128Decrypt(
  --   imageKeyDecrypted,
  --   imageKeyDecrypted,
  --   imageKeyDecrypted.Length,
  --   iv_key.Skip(16).Take(16).ToArray(),
  --   iv_key.Take(16).ToArray());
  cipher <- case cipherInit $ B.take 16 $ B.drop 16 iv_key of
    CryptoPassed cipher -> return cipher
    CryptoFailed e      -> fail $ "Couldn't set up EKPFS cipher: " <> show e
  iv <- case makeIV $ B.take 16 iv_key of
    Just iv -> return iv
    Nothing -> fail "Couldn't set up EKPFS IV"
  let imageKeyDecrypted = cbcDecrypt (cipher :: AES128) iv imageKeyEncrypted

  -- return Crypto.RSA2048Decrypt(imageKeyDecrypted, RSAKeyset.FakeKeyset);
  case decrypt Nothing fakeKeyset imageKeyDecrypted of
    Left  e -> fail $ "Couldn't do final decryption of EKPFS: " <> show e
    Right x -> return x

pfsGenEncKey :: B.ByteString -> B.ByteString -> Bool -> (B.ByteString, B.ByteString)
pfsGenEncKey = undefined

--------------------------------------------------------------------------------

fakeKeyset :: PrivateKey
fakeKeyset = PrivateKey
  { private_pub = PublicKey
    { public_size = 0x100
    , public_n {- Modulus -} = bytesToInteger $ B.pack
      [ 0xC6, 0xCF, 0x71, 0xE7, 0xE5, 0x9A, 0xF0, 0xD1, 0x2A, 0x2C, 0x45, 0x8B, 0xF9, 0x2A, 0x0E, 0xC1
      , 0x43, 0x05, 0x8B, 0xC3, 0x71, 0x17, 0x80, 0x1D, 0xCD, 0x49, 0x7D, 0xDE, 0x35, 0x9D, 0x25, 0x9B
      , 0xA0, 0xD7, 0xA0, 0xF2, 0x7D, 0x6C, 0x08, 0x7E, 0xAA, 0x55, 0x02, 0x68, 0x2B, 0x23, 0xC6, 0x44
      , 0xB8, 0x44, 0x18, 0xEB, 0x56, 0xCF, 0x16, 0xA2, 0x48, 0x03, 0xC9, 0xE7, 0x4F, 0x87, 0xEB, 0x3D
      , 0x30, 0xC3, 0x15, 0x88, 0xBF, 0x20, 0xE7, 0x9D, 0xFF, 0x77, 0x0C, 0xDE, 0x1D, 0x24, 0x1E, 0x63
      , 0xA9, 0x4F, 0x8A, 0xBF, 0x5B, 0xBE, 0x60, 0x19, 0x68, 0x33, 0x3B, 0xFC, 0xED, 0x9F, 0x47, 0x4E
      , 0x5F, 0xF8, 0xEA, 0xCB, 0x3D, 0x00, 0xBD, 0x67, 0x01, 0xF9, 0x2C, 0x6D, 0xC6, 0xAC, 0x13, 0x64
      , 0xE7, 0x67, 0x14, 0xF3, 0xDC, 0x52, 0x69, 0x6A, 0xB9, 0x83, 0x2C, 0x42, 0x30, 0x13, 0x1B, 0xB2
      , 0xD8, 0xA5, 0x02, 0x0D, 0x79, 0xED, 0x96, 0xB1, 0x0D, 0xF8, 0xCC, 0x0C, 0xDF, 0x81, 0x95, 0x4F
      , 0x03, 0x58, 0x09, 0x57, 0x0E, 0x80, 0x69, 0x2E, 0xFE, 0xFF, 0x52, 0x77, 0xEA, 0x75, 0x28, 0xA8
      , 0xFB, 0xC9, 0xBE, 0xBF, 0x9F, 0xBB, 0xB7, 0x79, 0x8E, 0x18, 0x05, 0xE1, 0x80, 0xBD, 0x50, 0x34
      , 0x94, 0x81, 0xD3, 0x53, 0xC2, 0x69, 0xA2, 0xD2, 0x4C, 0xCF, 0x6C, 0xF4, 0x57, 0x2C, 0x10, 0x4A
      , 0x3F, 0xFB, 0x22, 0xFD, 0x8B, 0x97, 0xE2, 0xC9, 0x5B, 0xA6, 0x2B, 0xCD, 0xD6, 0x1B, 0x6B, 0xDB
      , 0x68, 0x7F, 0x4B, 0xC2, 0xA0, 0x50, 0x34, 0xC0, 0x05, 0xE5, 0x8D, 0xEF, 0x24, 0x67, 0xFF, 0x93
      , 0x40, 0xCF, 0x2D, 0x62, 0xA2, 0xA0, 0x50, 0xB1, 0xF1, 0x3A, 0xA8, 0x3D, 0xFD, 0x80, 0xD1, 0xF9
      , 0xB8, 0x05, 0x22, 0xAF, 0xC8, 0x35, 0x45, 0x90, 0x58, 0x8E, 0xE3, 0x3A, 0x7C, 0xBD, 0x3E, 0x27
      ]
    , public_e {- PublicExponent -} = bytesToInteger $ B.pack [0, 1, 0, 1]
    }
  , private_d {- PrivateExponent -} = bytesToInteger $ B.pack
    [ 0x7F, 0x76, 0xCD, 0x0E, 0xE2, 0xD4, 0xDE, 0x05, 0x1C, 0xC6, 0xD9, 0xA8, 0x0E, 0x8D, 0xFA, 0x7B
    , 0xCA, 0x1E, 0xAA, 0x27, 0x1A, 0x40, 0xF8, 0xF1, 0x22, 0x87, 0x35, 0xDD, 0xDB, 0xFD, 0xEE, 0xF8
    , 0xC2, 0xBC, 0xBD, 0x01, 0xFB, 0x8B, 0xE2, 0x3E, 0x63, 0xB2, 0xB1, 0x22, 0x5C, 0x56, 0x49, 0x6E
    , 0x11, 0xBE, 0x07, 0x44, 0x0B, 0x9A, 0x26, 0x66, 0xD1, 0x49, 0x2C, 0x8F, 0xD3, 0x1B, 0xCF, 0xA4
    , 0xA1, 0xB8, 0xD1, 0xFB, 0xA4, 0x9E, 0xD2, 0x21, 0x28, 0x83, 0x09, 0x8A, 0xF6, 0xA0, 0x0B, 0xA3
    , 0xD6, 0x0F, 0x9B, 0x63, 0x68, 0xCC, 0xBC, 0x0C, 0x4E, 0x14, 0x5B, 0x27, 0xA4, 0xA9, 0xF4, 0x2B
    , 0xB9, 0xB8, 0x7B, 0xC0, 0xE6, 0x51, 0xAD, 0x1D, 0x77, 0xD4, 0x6B, 0xB9, 0xCE, 0x20, 0xD1, 0x26
    , 0x66, 0x7E, 0x5E, 0x9E, 0xA2, 0xE9, 0x6B, 0x90, 0xF3, 0x73, 0xB8, 0x52, 0x8F, 0x44, 0x11, 0x03
    , 0x0C, 0x13, 0x97, 0x39, 0x3D, 0x13, 0x22, 0x58, 0xD5, 0x43, 0x82, 0x49, 0xDA, 0x6E, 0x7C, 0xA1
    , 0xC5, 0x8C, 0xA5, 0xB0, 0x09, 0xE0, 0xCE, 0x3D, 0xDF, 0xF4, 0x9D, 0x3C, 0x97, 0x15, 0xE2, 0x6A
    , 0xC7, 0x2B, 0x3C, 0x50, 0x93, 0x23, 0xDB, 0xBA, 0x4A, 0x22, 0x66, 0x44, 0xAC, 0x78, 0xBB, 0x0E
    , 0x1A, 0x27, 0x43, 0xB5, 0x71, 0x67, 0xAF, 0xF4, 0xAB, 0x48, 0x46, 0x93, 0x73, 0xD0, 0x42, 0xAB
    , 0x93, 0x63, 0xE5, 0x6C, 0x9A, 0xDE, 0x50, 0x24, 0xC0, 0x23, 0x7D, 0x99, 0x79, 0x3F, 0x22, 0x07
    , 0xE0, 0xC1, 0x48, 0x56, 0x1B, 0xDF, 0x83, 0x09, 0x12, 0xB4, 0x2D, 0x45, 0x6B, 0xC9, 0xC0, 0x68
    , 0x85, 0x99, 0x90, 0x79, 0x96, 0x1A, 0xD7, 0xF5, 0x4D, 0x1F, 0x37, 0x83, 0x40, 0x4A, 0xEC, 0x39
    , 0x37, 0xA6, 0x80, 0x92, 0x7D, 0xC5, 0x80, 0xC7, 0xD6, 0x6F, 0xFE, 0x8A, 0x79, 0x89, 0xC6, 0xB1
    ]
  , private_p {- Prime1 -} = bytesToInteger $ B.pack
    [ 0xFE, 0xF6, 0xBF, 0x1D, 0x69, 0xAB, 0x16, 0x25, 0x08, 0x47, 0x55, 0x6B, 0x86, 0xE4, 0x35, 0x88
    , 0x72, 0x2A, 0xB1, 0x3D, 0xF8, 0xB6, 0x44, 0xCA, 0xB3, 0xAB, 0x19, 0xD1, 0x04, 0x24, 0x28, 0x0A
    , 0x74, 0x55, 0xB8, 0x15, 0x45, 0x09, 0xCC, 0x13, 0x1C, 0xF2, 0xBA, 0x37, 0xA9, 0x03, 0x90, 0x8F
    , 0x02, 0x10, 0xFF, 0x25, 0x79, 0x86, 0xCC, 0x18, 0x50, 0x9A, 0x10, 0x5F, 0x5B, 0x4C, 0x1C, 0x4E
    , 0xB0, 0xA7, 0xE3, 0x59, 0xB1, 0x2D, 0xA0, 0xC6, 0xB0, 0x20, 0x2C, 0x21, 0x33, 0x12, 0xB3, 0xAF
    , 0x72, 0x34, 0x83, 0xCD, 0x52, 0x2F, 0xAF, 0x0F, 0x20, 0x5A, 0x1B, 0xC0, 0xE2, 0xA3, 0x76, 0x34
    , 0x0F, 0xD7, 0xFC, 0xC1, 0x41, 0xC9, 0xF9, 0x79, 0x40, 0x17, 0x42, 0x21, 0x3E, 0x9D, 0xFD, 0xC7
    , 0xC1, 0x50, 0xDE, 0x44, 0x5A, 0xC9, 0x31, 0x89, 0x6A, 0x78, 0x05, 0xBE, 0x65, 0xB4, 0xE8, 0x2D
    ]
  , private_q {- Prime2 -} = bytesToInteger $ B.pack
    [ 0xC7, 0x9E, 0x47, 0x58, 0x00, 0x7D, 0x62, 0x82, 0xB0, 0xD2, 0x22, 0x81, 0xD4, 0xA8, 0x97, 0x1B
    , 0x79, 0x0C, 0x3A, 0xB0, 0xD7, 0xC9, 0x30, 0xE3, 0xC3, 0x53, 0x8E, 0x57, 0xEF, 0xF0, 0x9B, 0x9F
    , 0xB3, 0x90, 0x52, 0xC6, 0x94, 0x22, 0x36, 0xAA, 0xE6, 0x4A, 0x5F, 0x72, 0x1D, 0x70, 0xE8, 0x76
    , 0x58, 0xC8, 0xB2, 0x91, 0xCE, 0x9C, 0xC3, 0xE9, 0x09, 0x7F, 0x2E, 0x47, 0x97, 0xCC, 0x90, 0x39
    , 0x15, 0x35, 0x31, 0xDE, 0x1F, 0x0C, 0x8C, 0x0D, 0xC1, 0xC2, 0x92, 0xBE, 0x97, 0xBF, 0x2F, 0x91
    , 0xA1, 0x8C, 0x7D, 0x50, 0xA8, 0x21, 0x2F, 0xD7, 0xA2, 0x9A, 0x7E, 0xB5, 0xA7, 0x2A, 0x90, 0x02
    , 0xD9, 0xF3, 0x3D, 0xD1, 0xEB, 0xB8, 0xE0, 0x5A, 0x79, 0x9E, 0x7D, 0x8D, 0xCA, 0x18, 0x6D, 0xBD
    , 0x9E, 0xA1, 0x80, 0x28, 0x6B, 0x2A, 0xFE, 0x51, 0x24, 0x9B, 0x6F, 0x4D, 0x84, 0x77, 0x80, 0x23
    ]
  , private_dP {- Exponent1 -} = bytesToInteger $ B.pack
    [ 0x6D, 0x48, 0xE0, 0x54, 0x40, 0x25, 0xC8, 0x41, 0x29, 0x52, 0x42, 0x27, 0xEB, 0xD2, 0xC7, 0xAB
    , 0x6B, 0x9C, 0x27, 0x0A, 0xB4, 0x1F, 0x94, 0x4E, 0xFA, 0x42, 0x1D, 0xB7, 0xBC, 0xB9, 0xAE, 0xBC
    , 0x04, 0x6F, 0x75, 0x8F, 0x10, 0x5F, 0x89, 0xAC, 0xAB, 0x9C, 0xD2, 0xFA, 0xE6, 0xA4, 0x13, 0x83
    , 0x68, 0xD4, 0x56, 0x38, 0xFE, 0xE5, 0x2B, 0x78, 0x44, 0x9C, 0x34, 0xE6, 0x5A, 0xA0, 0xBE, 0x05
    , 0x70, 0xAD, 0x15, 0xC3, 0x2D, 0x31, 0xAC, 0x97, 0x5D, 0x88, 0xFC, 0xC1, 0x62, 0x3D, 0xE2, 0xED
    , 0x11, 0xDB, 0xB6, 0x9E, 0xFC, 0x5A, 0x5A, 0x03, 0xF6, 0xCF, 0x08, 0xD4, 0x5D, 0x90, 0xC9, 0x2A
    , 0xB9, 0x9B, 0xCF, 0xC8, 0x1A, 0x65, 0xF3, 0x5B, 0xE8, 0x7F, 0xCF, 0xA5, 0xA6, 0x4C, 0x5C, 0x2A
    , 0x12, 0x0F, 0x92, 0xA5, 0xE3, 0xF0, 0x17, 0x1E, 0x9A, 0x97, 0x45, 0x86, 0xFD, 0xDB, 0x54, 0x25
    ]
  , private_dQ {- Exponent2 -} = bytesToInteger $ B.pack
    [ 0x2A, 0x51, 0xCE, 0x02, 0x44, 0x28, 0x50, 0xE8, 0x30, 0x20, 0x7C, 0x9C, 0x55, 0xBF, 0x60, 0x39
    , 0xBC, 0xD1, 0xF0, 0xE7, 0x68, 0xF8, 0x08, 0x5B, 0x61, 0x1F, 0xA7, 0xBF, 0xD0, 0xE8, 0x8B, 0xB5
    , 0xB1, 0xD5, 0xD9, 0x16, 0xAC, 0x75, 0x0C, 0x6D, 0xF2, 0xE0, 0xB5, 0x97, 0x75, 0xD2, 0x68, 0x16
    , 0x1F, 0x00, 0x7D, 0x8B, 0x17, 0xE8, 0x78, 0x48, 0x41, 0x71, 0x2B, 0x18, 0x96, 0x80, 0x11, 0xDB
    , 0x68, 0x39, 0x9C, 0xD6, 0xE0, 0x72, 0x42, 0x86, 0xF0, 0x1B, 0x16, 0x0D, 0x3E, 0x12, 0x94, 0x3D
    , 0x25, 0xA8, 0xA9, 0x30, 0x9E, 0x54, 0x5A, 0xD6, 0x36, 0x6C, 0xD6, 0x8C, 0x20, 0x62, 0x8F, 0xA1
    , 0x6B, 0x1F, 0x7C, 0x6D, 0xB2, 0xB1, 0xC1, 0x2E, 0xAD, 0x36, 0x02, 0x9C, 0x3A, 0xCA, 0x2F, 0x09
    , 0xD2, 0x45, 0x9E, 0xEB, 0xF2, 0xBC, 0x6C, 0xAA, 0x3B, 0x3E, 0x90, 0xBC, 0x38, 0x67, 0x35, 0x4D
    ]
  , private_qinv {- Coefficient -} = bytesToInteger $ B.pack
    [ 0x0B, 0x67, 0x1C, 0x0D, 0x6C, 0x57, 0xD3, 0xE7, 0x05, 0x65, 0x94, 0x31, 0x56, 0x55, 0xFD, 0x28
    , 0x08, 0xFA, 0x05, 0x8A, 0xCC, 0x55, 0x39, 0x61, 0x97, 0x63, 0xA0, 0x16, 0x27, 0x3D, 0xED, 0xC1
    , 0x16, 0x40, 0x2A, 0x12, 0xEA, 0x6F, 0xD9, 0xD8, 0x58, 0x56, 0xA8, 0x56, 0x8B, 0x0D, 0x38, 0x5E
    , 0x1E, 0x80, 0x3B, 0x5F, 0x40, 0x80, 0x6F, 0x62, 0x4F, 0x28, 0xA2, 0x69, 0xF3, 0xD3, 0xF7, 0xFD
    , 0xB2, 0xC3, 0x52, 0x43, 0x20, 0x92, 0x9D, 0x97, 0x8D, 0xA0, 0x15, 0x07, 0x15, 0x6E, 0xA4, 0x0D
    , 0x56, 0xD3, 0x37, 0x1A, 0xC4, 0x9E, 0xDF, 0x02, 0x49, 0xB8, 0x0A, 0x84, 0x62, 0xF5, 0xFA, 0xB9
    , 0x3F, 0xA4, 0x09, 0x76, 0xCC, 0xAA, 0xB9, 0x9B, 0xA6, 0x4F, 0xC1, 0x6A, 0x64, 0xCE, 0xD8, 0x77
    , 0xAB, 0x4B, 0xF9, 0xA0, 0xAE, 0xDA, 0xF1, 0x67, 0x87, 0x7C, 0x98, 0x5C, 0x7E, 0xB8, 0x73, 0xF5
    ]
  }

pkgDerivedKey3Keyset :: PrivateKey
pkgDerivedKey3Keyset = PrivateKey
  { private_pub = PublicKey
    { public_size = 0x100
    , public_n {- Modulus -} = bytesToInteger $ B.pack
      [ 0xd2, 0x12, 0xfc, 0x33, 0x5f, 0x6d, 0xdb, 0x83, 0x16, 0x09, 0x62, 0x8b, 0x03, 0x56, 0x27, 0x37
      , 0x82, 0xd4, 0x77, 0x85, 0x35, 0x29, 0x39, 0x2d, 0x52, 0x6b, 0x8c, 0x4c, 0x8c, 0xfb, 0x06, 0xc1
      , 0x84, 0x5b, 0xe7, 0xd4, 0xf7, 0xbc, 0xd2, 0x4e, 0x62, 0x45, 0xcd, 0x2a, 0xbb, 0xd7, 0x77, 0x76
      , 0x45, 0x36, 0x55, 0x27, 0x3f, 0xb3, 0xf5, 0xf9, 0x8e, 0xda, 0x4b, 0xef, 0xaa, 0x59, 0xae, 0xb3
      , 0x9b, 0xea, 0x54, 0x98, 0xd2, 0x06, 0x32, 0x6a, 0x58, 0x31, 0x2a, 0xe0, 0xd4, 0x4f, 0x90, 0xb5
      , 0x0a, 0x7d, 0xec, 0xf4, 0x3a, 0x9c, 0x52, 0x67, 0x2d, 0x99, 0x31, 0x8e, 0x0c, 0x43, 0xe6, 0x82
      , 0xfe, 0x07, 0x46, 0xe1, 0x2e, 0x50, 0xd4, 0x1f, 0x2d, 0x2f, 0x7e, 0xd9, 0x08, 0xba, 0x06, 0xb3
      , 0xbf, 0x2e, 0x20, 0x3f, 0x4e, 0x3f, 0xfe, 0x44, 0xff, 0xaa, 0x50, 0x43, 0x57, 0x91, 0x69, 0x94
      , 0x49, 0x15, 0x82, 0x82, 0xe4, 0x0f, 0x4c, 0x8d, 0x9d, 0x2c, 0xc9, 0x5b, 0x1d, 0x64, 0xbf, 0x88
      , 0x8b, 0xd4, 0xc5, 0x94, 0xe7, 0x65, 0x47, 0x84, 0x1e, 0xe5, 0x79, 0x10, 0xfb, 0x98, 0x93, 0x47
      , 0xb9, 0x7d, 0x85, 0x12, 0xa6, 0x40, 0x98, 0x2c, 0xf7, 0x92, 0xbc, 0x95, 0x19, 0x32, 0xed, 0xe8
      , 0x90, 0x56, 0x0d, 0x65, 0xc1, 0xaa, 0x78, 0xc6, 0x2e, 0x54, 0xfd, 0x5f, 0x54, 0xa1, 0xf6, 0x7e
      , 0xe5, 0xe0, 0x5f, 0x61, 0xc1, 0x20, 0xb4, 0xb9, 0xb4, 0x33, 0x08, 0x70, 0xe4, 0xdf, 0x89, 0x56
      , 0xed, 0x01, 0x29, 0x46, 0x77, 0x5f, 0x8c, 0xb8, 0xa9, 0xf5, 0x1e, 0x2e, 0xb3, 0xb9, 0xbf, 0xe0
      , 0x09, 0xb7, 0x8d, 0x28, 0xd4, 0xa6, 0xc3, 0xb8, 0x1e, 0x1f, 0x07, 0xeb, 0xb4, 0x12, 0x0b, 0x95
      , 0xb8, 0x85, 0x30, 0xfd, 0xdc, 0x39, 0x13, 0xd0, 0x7c, 0xdc, 0x8f, 0xed, 0xf9, 0xc9, 0xa3, 0xc1
      ]
    , public_e {- PublicExponent -} = bytesToInteger $ B.pack [0, 1, 0, 1]
    }
  , private_d {- PrivateExponent -} = bytesToInteger $ B.pack
    [ 0x32, 0xD9, 0x03, 0x90, 0x8F, 0xBD, 0xB0, 0x8F, 0x57, 0x2B, 0x28, 0x5E, 0x0B, 0x8D, 0xB3, 0xEA
    , 0x5C, 0xD1, 0x7E, 0xA8, 0x90, 0x88, 0x8C, 0xDD, 0x6A, 0x80, 0xBB, 0xB1, 0xDF, 0xC1, 0xF7, 0x0D
    , 0xAA, 0x32, 0xF0, 0xB7, 0x7C, 0xCB, 0x88, 0x80, 0x0E, 0x8B, 0x64, 0xB0, 0xBE, 0x4C, 0xD6, 0x0E
    , 0x9B, 0x8C, 0x1E, 0x2A, 0x64, 0xE1, 0xF3, 0x5C, 0xD7, 0x76, 0x01, 0x41, 0x5E, 0x93, 0x5C, 0x94
    , 0xFE, 0xDD, 0x46, 0x62, 0xC3, 0x1B, 0x5A, 0xE2, 0xA0, 0xBC, 0x2D, 0xEB, 0xC3, 0x98, 0x0A, 0xA7
    , 0xB7, 0x85, 0x69, 0x70, 0x68, 0x2B, 0x64, 0x4A, 0xB3, 0x1F, 0xCC, 0x7D, 0xDC, 0x7C, 0x26, 0xF4
    , 0x77, 0xF6, 0x5C, 0xF2, 0xAE, 0x5A, 0x44, 0x2D, 0xD3, 0xAB, 0x16, 0x62, 0x04, 0x19, 0xBA, 0xFB
    , 0x90, 0xFF, 0xE2, 0x30, 0x50, 0x89, 0x6E, 0xCB, 0x56, 0xB2, 0xEB, 0xC0, 0x91, 0x16, 0x92, 0x5E
    , 0x30, 0x8E, 0xAE, 0xC7, 0x94, 0x5D, 0xFD, 0x35, 0xE1, 0x20, 0xF8, 0xAD, 0x3E, 0xBC, 0x08, 0xBF
    , 0xC0, 0x36, 0x74, 0x9F, 0xD5, 0xBB, 0x52, 0x08, 0xFD, 0x06, 0x66, 0xF3, 0x7A, 0xB3, 0x04, 0xF4
    , 0x75, 0x29, 0x5D, 0xE9, 0x5F, 0xAA, 0x10, 0x30, 0xB2, 0x0F, 0x5A, 0x1A, 0xC1, 0x2A, 0xB3, 0xFE
    , 0xCB, 0x21, 0xAD, 0x80, 0xEC, 0x8F, 0x20, 0x09, 0x1C, 0xDB, 0xC5, 0x58, 0x94, 0xC2, 0x9C, 0xC6
    , 0xCE, 0x82, 0x65, 0x3E, 0x57, 0x90, 0xBC, 0xA9, 0x8B, 0x06, 0xB4, 0xF0, 0x72, 0xF6, 0x77, 0xDF
    , 0x98, 0x64, 0xF1, 0xEC, 0xFE, 0x37, 0x2D, 0xBC, 0xAE, 0x8C, 0x08, 0x81, 0x1F, 0xC3, 0xC9, 0x89
    , 0x1A, 0xC7, 0x42, 0x82, 0x4B, 0x2E, 0xDC, 0x8E, 0x8D, 0x73, 0xCE, 0xB1, 0xCC, 0x01, 0xD9, 0x08
    , 0x70, 0x87, 0x3C, 0x44, 0x08, 0xEC, 0x49, 0x8F, 0x81, 0x5A, 0xE2, 0x40, 0xFF, 0x77, 0xFC, 0x0D
    ]
  , private_p {- Prime1 -} = bytesToInteger $ B.pack
    [ 0xF9, 0x67, 0xAD, 0x99, 0x12, 0x31, 0x0C, 0x56, 0xA2, 0x2E, 0x16, 0x1C, 0x46, 0xB3, 0x4D, 0x5B
    , 0x43, 0xBE, 0x42, 0xA2, 0xF6, 0x86, 0x96, 0x80, 0x42, 0xC3, 0xC7, 0x3F, 0xC3, 0x42, 0xF5, 0x87
    , 0x49, 0x33, 0x9F, 0x07, 0x5D, 0x6E, 0x2C, 0x04, 0xFD, 0xE3, 0xE1, 0xB2, 0xAE, 0x0A, 0x0C, 0xF0
    , 0xC7, 0xA6, 0x1C, 0xA1, 0x63, 0x50, 0xC8, 0x09, 0x9C, 0x51, 0x24, 0x52, 0x6C, 0x5E, 0x5E, 0xBD
    , 0x1E, 0x27, 0x06, 0xBB, 0xBC, 0x9E, 0x94, 0xE1, 0x35, 0xD4, 0x6D, 0xB3, 0xCB, 0x3C, 0x68, 0xDD
    , 0x68, 0xB3, 0xFE, 0x6C, 0xCB, 0x8D, 0x82, 0x20, 0x76, 0x23, 0x63, 0xB7, 0xE9, 0x68, 0x10, 0x01
    , 0x4E, 0xDC, 0xBA, 0x27, 0x5D, 0x01, 0xC1, 0x2D, 0x80, 0x5E, 0x2B, 0xAF, 0x82, 0x6B, 0xD8, 0x84
    , 0xB6, 0x10, 0x52, 0x86, 0xA7, 0x89, 0x8E, 0xAE, 0x9A, 0xE2, 0x89, 0xC6, 0xF7, 0xD5, 0x87, 0xFB
    ]
  , private_q {- Prime2 -} = bytesToInteger $ B.pack
    [ 0xD7, 0xA1, 0x0F, 0x9A, 0x8B, 0xF2, 0xC9, 0x11, 0x95, 0x32, 0x9A, 0x8C, 0xF0, 0xD9, 0x40, 0x47
    , 0xF5, 0x68, 0xA0, 0x0D, 0xBD, 0xC1, 0xFC, 0x43, 0x2F, 0x65, 0xF9, 0xC3, 0x61, 0x0F, 0x25, 0x77
    , 0x54, 0xAD, 0xD7, 0x58, 0xAC, 0x84, 0x40, 0x60, 0x8D, 0x3F, 0xF3, 0x65, 0x89, 0x75, 0xB5, 0xC6
    , 0x2C, 0x51, 0x1A, 0x2F, 0x1F, 0x22, 0xE4, 0x43, 0x11, 0x54, 0xBE, 0xC9, 0xB4, 0xC7, 0xB5, 0x1B
    , 0x05, 0x0B, 0xBC, 0x56, 0x9A, 0xCD, 0x4A, 0xD9, 0x73, 0x68, 0x5E, 0x5C, 0xFB, 0x92, 0xB7, 0x8B
    , 0x0D, 0xFF, 0xF5, 0x07, 0xCA, 0xB4, 0xC8, 0x9B, 0x96, 0x3C, 0x07, 0x9E, 0x3E, 0x6B, 0x2A, 0x11
    , 0xF2, 0x8A, 0xB1, 0x8A, 0xD7, 0x2E, 0x1B, 0xA5, 0x53, 0x24, 0x06, 0xED, 0x50, 0xB8, 0x90, 0x67
    , 0xB1, 0xE2, 0x41, 0xC6, 0x92, 0x01, 0xEE, 0x10, 0xF0, 0x61, 0xBB, 0xFB, 0xB2, 0x7D, 0x4A, 0x73
    ]
  , private_dP {- Exponent1 -} = bytesToInteger $ B.pack
    [ 0x52, 0xCC, 0x2D, 0xA0, 0x9C, 0x9E, 0x75, 0xE7, 0x28, 0xEE, 0x3D, 0xDE, 0xE3, 0x45, 0xD1, 0x4F
    , 0x94, 0x1C, 0xCC, 0xC8, 0x87, 0x29, 0x45, 0x3B, 0x8D, 0x6E, 0xAB, 0x6E, 0x2A, 0xA7, 0xC7, 0x15
    , 0x43, 0xA3, 0x04, 0x8F, 0x90, 0x5F, 0xEB, 0xF3, 0x38, 0x4A, 0x77, 0xFA, 0x36, 0xB7, 0x15, 0x76
    , 0xB6, 0x01, 0x1A, 0x8E, 0x25, 0x87, 0x82, 0xF1, 0x55, 0xD8, 0xC6, 0x43, 0x2A, 0xC0, 0xE5, 0x98
    , 0xC9, 0x32, 0xD1, 0x94, 0x6F, 0xD9, 0x01, 0xBA, 0x06, 0x81, 0xE0, 0x6D, 0x88, 0xF2, 0x24, 0x2A
    , 0x25, 0x01, 0x64, 0x5C, 0xBF, 0xF2, 0xD9, 0x99, 0x67, 0x3E, 0xF6, 0x72, 0xEE, 0xE4, 0xE2, 0x33
    , 0x5C, 0xF8, 0x00, 0x40, 0xE3, 0x2A, 0x9A, 0xF4, 0x3D, 0x22, 0x86, 0x44, 0x3C, 0xFB, 0x0A, 0xA5
    , 0x7C, 0x3F, 0xCC, 0xF5, 0xF1, 0x16, 0xC4, 0xAC, 0x88, 0xB4, 0xDE, 0x62, 0x94, 0x92, 0x6A, 0x13
    ]
  , private_dQ {- Exponent2 -} = bytesToInteger $ B.pack
    [ 0x7C, 0x9D, 0xAD, 0x39, 0xE0, 0xD5, 0x60, 0x14, 0x94, 0x48, 0x19, 0x7F, 0x88, 0x95, 0xD5, 0x8B
    , 0x80, 0xAD, 0x85, 0x8A, 0x4B, 0x77, 0x37, 0x85, 0xD0, 0x77, 0xBB, 0xBF, 0x89, 0x71, 0x4A, 0x72
    , 0xCB, 0x72, 0x68, 0x38, 0xEC, 0x02, 0xC6, 0x7D, 0xC6, 0x44, 0x06, 0x33, 0x51, 0x1C, 0xC0, 0xFF
    , 0x95, 0x8F, 0x0D, 0x75, 0xDC, 0x25, 0xBB, 0x0B, 0x73, 0x91, 0xA9, 0x6D, 0x42, 0xD8, 0x03, 0xB7
    , 0x68, 0xD4, 0x1E, 0x75, 0x62, 0xA3, 0x70, 0x35, 0x79, 0x78, 0x00, 0xC8, 0xF5, 0xEF, 0x15, 0xB9
    , 0xFC, 0x4E, 0x47, 0x5A, 0xC8, 0x70, 0x70, 0x5B, 0x52, 0x98, 0xC0, 0xC2, 0x58, 0x4A, 0x70, 0x96
    , 0xCC, 0xB8, 0x10, 0xE1, 0x2F, 0x78, 0x8B, 0x2B, 0xA1, 0x7F, 0xF9, 0xAC, 0xDE, 0xF0, 0xBB, 0x2B
    , 0xE2, 0x66, 0xE3, 0x22, 0x92, 0x31, 0x21, 0x57, 0x92, 0xC4, 0xB8, 0xF2, 0x3E, 0x76, 0x20, 0x37
    ]
  , private_qinv {- Coefficient -} = bytesToInteger $ B.pack
    [ 0x45, 0x97, 0x55, 0xD4, 0x22, 0x08, 0x5E, 0xF3, 0x5C, 0xB4, 0x05, 0x7A, 0xFD, 0xAA, 0x42, 0x42
    , 0xAD, 0x9A, 0x8C, 0xA0, 0x6C, 0xBB, 0x1D, 0x68, 0x54, 0x54, 0x6E, 0x3E, 0x32, 0xE3, 0x53, 0x73
    , 0x76, 0xF1, 0x3E, 0x01, 0xEA, 0xD3, 0xCF, 0xEB, 0xEB, 0x23, 0x3E, 0xC0, 0xBE, 0xCE, 0xEC, 0x2C
    , 0x89, 0x5F, 0xA8, 0x27, 0x3A, 0x4C, 0xB7, 0xE6, 0x74, 0xBC, 0x45, 0x4C, 0x26, 0xC8, 0x25, 0xFF
    , 0x34, 0x63, 0x25, 0x37, 0xE1, 0x48, 0x10, 0xC1, 0x93, 0xA6, 0xAF, 0xEB, 0xBA, 0xE3, 0xA2, 0xF1
    , 0x3D, 0xEF, 0x63, 0xD8, 0xF4, 0xFD, 0xD3, 0xEE, 0xE2, 0x5D, 0xE9, 0x33, 0xCC, 0xAD, 0xBA, 0x75
    , 0x5C, 0x85, 0xAF, 0xCE, 0xA9, 0x3D, 0xD1, 0xA2, 0x17, 0xF3, 0xF6, 0x98, 0xB3, 0x50, 0x8E, 0x5E
    , 0xF6, 0xEB, 0x02, 0x8E, 0xA1, 0x62, 0xA7, 0xD6, 0x2C, 0xEC, 0x91, 0xFF, 0x15, 0x40, 0xD2, 0xE3
    ]
  }
